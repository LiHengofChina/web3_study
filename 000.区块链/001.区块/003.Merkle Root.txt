
//========================================= Merkle Root
//========================================= Merkle Root

一种 树状结构的多层哈希汇总
Merkle Root ≈ 哈希( 哈希(交易1 + 交易2), 哈希(交易3 + 交易4) ... )



//========================================= 与 签名算法 对比
//========================================= 与 签名算法 对比


Merkle Root 和签名算法的共同点是：

都是为了校验数据是否被篡改
Merkle Root：只是哈希计算，不使用密钥加密

//========================================= 如何快速验证
//========================================= 如何快速验证

 	✅ 快速验证某个交易是否在区块中
	✅ 保证所有交易的完整性、一致性

Merkle Root 是用哈希函数（无密钥）递归计算出的交易 "总哈希" ，类似摘要，

//========================================= 快速验证 "某个交易" 是否在区块中
//========================================= 快速验证 "某个交易" 是否在区块中

用的是：Merkle Tree + Merkle Proof

//================= 一、Merkle Tree 是什么？
//================= 一、Merkle Tree 是什么？
它是一棵 "二叉树" ，底层是交易的哈希，上层逐层组合哈希，直到算出Merkle Root。
例子（4 个交易）：
    Merkle Root
       /    \
   A+B      C+D
   / \      / \
 A   B    C   D
/**
其中：
	A = hash(交易1)
	B = hash(交易2)
	C = hash(交易3)
	D = hash(交易4)
*/

//================= 二、如何验证 "某个交易是否存在" ？
//================= 二、如何验证 "某个交易是否存在" ？

你不需要 "全树" ，
					/**
						"全树" 整棵 Merkle 树，也就是从根（Merkle Root）到底层所有交易节点的完整结构
						//========================================
						//========================================
						举个例子：有 4 笔交易（A、B、C、D）
						Merkle 树长这样：
						          Merkle Root
									 /    \
								 H1        H2
								/  \      /  \
							 A      B   C     D
						A、B、C、D 是交易的哈希
						H1 = hash(A + B)
						H2 = hash(C + D)
						Merkle Root = hash(H1 + H2)

						所谓“全树”就是指你知道：
						（1）所有交易的哈希（A、B、C、D）
						（2）所有中间层哈希（H1、H2）
						（3）Merkle Root
						//======================================== 你不需要全树”的意思是：
						//======================================== 你不需要全树”的意思是：
						你不用知道 "所有交易" 和 "所有中间节点"，
						你只需要一小段路径（Merkle Proof），就能验证一个交易是否存在！
						举例：只验证“交易 A 是否存在”时，你只需要：
						hash(A)
						hash(B)（A 的兄弟节点）
						hash(H2)（另一边的兄弟分支）
						就能计算出 Merkle Root，看是否一致。
						//======================================== 不需要全树
						//======================================== 不需要全树
						不需要全树是想说明，计算量少就能证明，不用计算全部节点、更快是吗，所以才把merkleRoot 设置成 二叉树

						Merkle 树的设计目的之一，就是为了用 "最少的数据" 就能验证某笔交易是否存在于区块中（高效 + 安全）。

						为什么用"二叉树" ？（Merkle Tree 是一种二叉哈希树）
						每次合并两个节点 → 逐层减少数量 → 最后只剩一个根
						任何节点只需要**对数级别（log₂ n）**的兄弟节点就能验证（非常高效）
						比如：1000 笔交易 → 只要约 10 个哈希就能证明任意一笔存在
						//======================================== 只有最底层才是真实交易的哈希值，其他上层都是中间节点（中间哈希）。
						//======================================== 只有最底层才是真实交易的哈希值，其他上层都是中间节点（中间哈希）。
						         Merkle Root
								   /     \
								H1         H2
							   / \        / \
						   h(A) h(B)   h(C) h(D)

						   h(A) = hash(交易A) 👉 叶子节点
						   H1 = hash(h(A) + h(B)) 👉 中间节点
						   Merkle Root = hash(H1 + H2) 👉 根节点（顶）

					*/

只要一条 "证明路径（Merkle Proof）" 。
					/**
						在 Merkle 二叉树中，
						从某个交易节点一路 "向上" 计算到 Merkle Root 所需要的所有 "兄弟节点" 哈希值，
						 "这条链式结构" 就叫 "证明路径"。
						//======================================== 
						//========================================
						举个例子（4 个交易）：
							  Merkle Root
								 /    \
							 H1        H2
							/  \      /  \
						 A      B   C     D

						你想验证 交易 A 是否在这棵树里：
						你知道 A = hash(交易A) ✅
						要算出 H1，需要 A 和 B
						要算出 Merkle Root，需要 H1 和 H2
						
						✅ 所以 “证明路径” 是：
						A → B（兄弟） → H2（上层另一侧）
						（1）你提供 A 的原始值（或哈希）
						（2）再加上 这些兄弟节点的哈希（B 和 H2）
						（3）就可以逐层“哈希拼接”，算出 Merkle Root 去比对 ✅
					*/



你只需知道：
	（1）A = hash(交易1)
	（2）邻居 B（用来算 A+B）
	（3）上层兄弟节点 C+D（用来算 Merkle Root）
用这些就能"重建" Merkle Root 与区块中的对比 → 一致就说明它存在。




