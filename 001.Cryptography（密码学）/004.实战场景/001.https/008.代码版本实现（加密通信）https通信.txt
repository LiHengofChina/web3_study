


如果你有一个 Web 服务，运行在 Tomcat 上，客户端（如浏览器或其他服务）访问这个 Web 服务时，
可以通过在 Tomcat 的 server.xml 文件中配置 HTTPS（通过 SSLEnabled="true"、keystoreFile、truststoreFile 等配置），
这样客户端访问时会自动建立加密的 HTTPS 连接。



如果是两个后台服务之间的HTTP/HTTPS 调用（例如微服务之间的通信、后台 API 调用），你可能需要通过代码来手动管理和建立 HTTPS 连接。


//====================================================================== 代码版本（代码方式的 HTTPS 配置）：
//====================================================================== 代码版本（代码方式的 HTTPS 配置）：
通过编程的方式设置 SSL/TLS 配置，实现带有加密的 Socket 连接。

这段代码使用 Java 的 SSLContext 和 SSLServerSocket 来实现一个类似于 Tomcat HTTPS 配置的功能，
手动加载密钥库（keystore）和信任库（truststore），
并创建一个加密的服务器 Socket（SSLServerSocket），确保通信是通过 SSL/TLS 进行的。

//======================================================================（服务端）
//======================================================================（服务端）

//（1）创建 SSLContext 实例：
SSLContext ctx = SSLContext.getInstance("SSL");

	//创建一个 SSLContext 实例，它是用于配置 SSL/TLS 协议的上下文环境。
	//"SSL" 指定了协议，虽然现代应用中推荐使用 "TLS"，这里使用 "SSL" 可能是为了兼容旧版本。


//（2）创建 KeyManagerFactory 和 TrustManagerFactory 实例：
KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");
		//用于管理和初始化密钥库中的私钥和证书，支持服务器的身份认证（通常由 keystore 提供）。
TrustManagerFactory tmf = TrustManagerFactory.getInstance("SunX509");
		//TrustManagerFactory：用于管理和初始化信任库中的证书，用来验证客户端或远程服务器的证书（通常由 truststore 提供）。


//（3）加载密钥库和信任库：
//加载服务器的密钥库，包含服务器的私钥和公钥证书，这将用于服务器的身份认证。
KeyStore ks = KeyStore.getInstance("JKS");
ks.load(new FileInputStream("data/kserver.keystore"), SERVER_KEY_STORE_PASSWORD.toCharArray());

//加载服务器的信任库，包含受信任的证书，通常用于验证客户端的身份（如果启用了客户端认证 clientAuth="true"）。
KeyStore tks = KeyStore.getInstance("JKS");
tks.load(new FileInputStream("data/tserver.keystore"), SERVER_TRUST_KEY_STORE_PASSWORD.toCharArray());


//（5）初始化 KeyManagerFactory 和 TrustManagerFactory：
kmf.init(ks, SERVER_KEY_STORE_PASSWORD.toCharArray());
tmf.init(tks);


//（6）初始化 SSLContext：
ctx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);


//（7）创建 SSL 服务器套接字：
return (SSLServerSocket) ctx.getServerSocketFactory().createServerSocket(DEFAULT_PORT);

//======================================================================（客户端）
//======================================================================（客户端）

 
 
private DefaultHttpClient getIgnoreSSLHttpClient(int sslPort) throws Exception {
	httpclient = new DefaultHttpClient();
	SSLContext sslContext = SSLContext.getInstance("TLS");
	X509TrustManager tm = new X509TrustManager() {
		public X509Certificate[] getAcceptedIssuers() {
			return null;
		}
		public void checkClientTrusted(X509Certificate[] certs, String authType) {
		}
		public void checkServerTrusted(X509Certificate[] certs, String authType) {
			System.out.println("server:" + certs[0]);
		}
	};
	sslContext.init(null, new TrustManager[] { tm }, null);
	SSLSocketFactory sf = new SSLSocketFactory(sslContext);
	Scheme sch = new Scheme("https", sslPort, sf);
	httpclient.getConnectionManager().getSchemeRegistry().register(sch);
	return httpclient;
}
//======================================================================（客户端）
//======================================================================（客户端）
单向认证（One-Way Authentication）**的 HTTP 客户端

private DefaultHttpClient getOneWayAuthSSLHttpClient(final String ip, int sslPort) throws Exception {
	httpclient = new DefaultHttpClient();
	SSLContext sslContext = SSLContext.getInstance("TLS");
	X509TrustManager tm = new X509TrustManager() {
		public X509Certificate[] getAcceptedIssuers() {
			return new X509Certificate[0];
		}
		public void checkClientTrusted(X509Certificate[] certs, String authType) {
		}
		public void checkServerTrusted(X509Certificate[] certs, String authType) throws CertificateException {
			if (certs == null || certs.length == 0)
				throw new IllegalArgumentException(
						"null or zero-length certificate chain");

			if (authType == null || authType.length() == 0)
				throw new IllegalArgumentException(
						"null or zero-length authentication type");
			boolean br = false;
			for (X509Certificate x509Certificate : certs) {
				String issuer = x509Certificate.getIssuerDN().toString();
				if (issuer.contains("CN=" + ip)) {
					br = true;
					return;
				}
			}
			if (!br) {
				throw new CertificateException("authen failed!");
			}
		}
	};
	sslContext.init(null, new TrustManager[] { tm }, null);
	SSLSocketFactory sf = new SSLSocketFactory(sslContext);
	Scheme sch = new Scheme("https", sslPort, sf);
	httpclient.getConnectionManager().getSchemeRegistry().register(sch);
	return httpclient;
}
